import { Event, StateValue, Action, StandardMachine, ParallelMachine, SimpleOrCompoundStateNodeConfig, MachineConfig, ParallelMachineConfig, EventType, StandardMachineConfig, Activity, ConditionalTransitionConfig, EntryExitStates, _StateTransition, StateValueMap, MachineOptions } from './types';
import { State } from './State';
declare class StateNode implements StateNode {
    config: SimpleOrCompoundStateNodeConfig | StandardMachineConfig | ParallelMachineConfig;
    options: MachineOptions;
    key: string;
    id: string;
    path: string[];
    initial?: string;
    parallel?: boolean;
    transient: boolean;
    states: Record<string, StateNode>;
    history: false | 'shallow' | 'deep';
    on: Record<string, ConditionalTransitionConfig>;
    onEntry: Action[];
    onExit: Action[];
    activities?: Activity[];
    strict: boolean;
    parent?: StateNode;
    machine: StateNode;
    data: object | undefined;
    delimiter: string;
    private __cache;
    private idMap;
    constructor(config: SimpleOrCompoundStateNodeConfig | StandardMachineConfig | ParallelMachineConfig, options?: MachineOptions);
    getStateNodes(state: StateValue | State): StateNode[];
    handles(event: Event): boolean;
    _transitionLeafNode(stateValue: string, state: State, event: Event, extendedState?: any): _StateTransition;
    _transitionHierarchicalNode(stateValue: StateValueMap, state: State, event: Event, extendedState?: any): _StateTransition;
    _transitionOrthogonalNode(stateValue: StateValueMap, state: State, event: Event, extendedState?: any): _StateTransition;
    _transition(stateValue: StateValue, state: State, event: Event, extendedState?: any): _StateTransition;
    _next(state: State, event: Event, extendedState?: any): _StateTransition;
    _getEntryExitStates(nextStateNode: StateNode, internal: boolean): EntryExitStates;
    private _evaluateCond(condition, extendedState, eventObject, interimState);
    private _getActions(transition);
    private _getActivities(state, transition);
    transition(state: StateValue | State, event: Event, extendedState?: any): State;
    private ensureValidPaths(paths);
    getStateNode(stateKey: string): StateNode;
    getStateNodeById(stateId: string): StateNode;
    private resolve(stateValue);
    private readonly resolvedStateValue;
    private getResolvedPath(stateIdentifier);
    private readonly initialStateValue;
    readonly initialState: State;
    readonly target: StateValue | undefined;
    getStates(stateValue: StateValue): StateNode[];
    /**
     * Returns the leaf nodes from a state path relative to this state node.
     *
     * @param relativeStateId The relative state path to retrieve the state nodes
     * @param history The previous state to retrieve history
     * @param resolve Whether state nodes should resolve to initial child state nodes
     */
    getRelativeStateNodes(relativeStateId: string | string[], history?: State, resolve?: boolean): StateNode[];
    readonly initialStateNodes: StateNode[];
    getFromRelativePath(relativePath: string[], historyValue?: StateValue): StateNode[];
    private resolveHistory(historyValue?);
    readonly events: EventType[];
    private formatTransition(targets, transitionConfig?);
    private formatTransitions(onConfig);
}
export declare function Machine(config: MachineConfig | ParallelMachineConfig, options: MachineOptions): StandardMachine | ParallelMachine;
export { StateNode };
